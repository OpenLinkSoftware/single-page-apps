
<!-- TODO - Add button feedback -->

<!DOCTYPE html>
<html lang="en">
	<head>
		<title> Basic Data Entry Form </title>
		<!-- Latest compiled and minified CSS -->
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/css/bootstrap.min.css">
		<!-- jQuery library -->
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
		<!-- Latest compiled JavaScript -->
		<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/js/bootstrap.min.js"></script>
		<!-- Authentication and RDF procssing library 
        <script src="./common/js/solid-auth-client.bundle.js"></script>
        <script src="./common/js/rdflib.min.js"></script>
        -->
        <script src="https://cdn.jsdelivr.net/npm/solid-auth-client@2.3.0/dist-lib/solid-auth-client.bundle.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/rdflib@0.20.1/dist/rdflib.min.js"></script>
	</head>

	<body>
	<!-- Start of tabs container -->
	<div class="container">
	  <!-- Create tabs menu -->
	  <ul class="nav nav-tabs">
	    <li class="active" id="dbmsTabID"><a data-toggle="tab" href="#dbmsID">DBMS</a></li>
	    <li id="fsTabID"><a data-toggle="tab" href="#fsID">File System</a></li>
	  </ul>
	  <!-- End of tabs menu -->
  
	  <!-- Add content to the tabs-->
	  <div class="tab-content">
		<!-- Start DBMS Tab -->
	    <div id="dbmsID" class="tab-pane fade in active">
		  	<div class="container">
		  	    <div class="row">
			  		<!-- Form Div (Left Side) -->
		  	        <div class="col-xs-6">
		  				<h1 style="text-align:center">Data Entry</h1>
		  				<form id="dbmsFormID" class="form" method="post">
		  					<div class="form-group">
		  						<label for="subjectID">Subject</label>
		  						<span class="glyphicon glyphicon-question-sign" data-toggle="tooltip" data-original-title="If the subject is not a URI it will be used as the fragment identifier of a Relative URI."></span> 
		  						<input type="text" class="form-control" placeholder="Subject" id="subjectID">
		  						<p class="errorMessage" id="subjectErrorID" ></p>
		  					</div>
		  					<div class="form-group">
		  						<label for="predicateID">Predicate</label>
		  						<span class="glyphicon glyphicon-question-sign" data-toggle="tooltip" data-original-title="The predicate can either be a URI (ex. http://xmlns.com/foaf/0.1/name) or a curie (ex. foaf:name) because these are preloaded in Virtuoso."></span> 
		  						<input type="text" class="form-control" placeholder="Predicate" id="predicateID">
		  						<p class="errorMessage" id="predicateErrorID" ></p>
		  					</div>
		  					<div class="form-group">
		  						<label for="objectID">Object</label> <span class="glyphicon glyphicon-question-sign" data-toggle="tooltip" data-original-title="Wether or not the Object is a literal value or a reference is determined by the range of the predicate. Quoting the Object will override this feature and make it a literal value."></span> 
		  						<input type="text" class="form-control" placeholder="Object" id="objectID">
		  					</div>
		  					<div class="form-group">
		  						<label for="docNameID">Document Name</label>
		  						<input type="text" class="form-control" value="urn:records:test" id="docNameID">
		  						<p class="errorMessage" id="docNameErrorID" ></p>
		  					</div>
		  					<div class="form-group">
		  						<label for="endpointID">SPARQL Endpoint</label> <span class="glyphicon glyphicon-question-sign" data-toggle="tooltip" data-original-title="Required for accepted relation object (values) lookup"></span> 
		  						<input type="text" class="form-control" id="endpointID" size="35" value="https://linkeddata.uriburner.com/sparql"/>
		  					</div>
				
		  					<!-- Start Buttons -->
		  					<div class=button-wrapper>
		  					<span>
							<button id="clearBtnID" type="button" onclick="clearDBMS()" class="btn btn-primary">Clear</button>
		  					<button id="insertBtnID" type="button" onclick="recordGen()" class="btn btn-success">Add</button> 
		  					<button id="deleteBtnID" type="button" onclick="recordDel()" class="btn btn-danger">Delete</button> 
		  					<button id="queryBtnID" type="button" onclick="queryGen()" class="btn btn-warning">Query</button> 
		  					<button id="dataBtnID" type="button" onclick="updateTable()" class="btn btn-info">All Data</button>
							</span>
		  					</div>
							<!-- Start Authentication Buttons -->
							<br/>
							<div class="button-wrapper">
							<button id="loginID" type="button" onclick="authLogin()" class="hidden btn btn-primary">Login</button> 
							<button id="logoutID" type="button" onclick="authLogout()" class="hidden btn btn-danger">Logout</button> 
			                <span>&nbsp&nbsp</span>
							<a id="logged-href" href="" title="" class="hidden"><img id="uid-icon" src="./common/uid.png"></a>
							</div>
							<!-- End Authentication Buttons -->
		  					<!-- End Buttons -->
		  				</form>
		  				<!-- End of Form Div -->
				
		  			<!--Start Table Div (Right Side) -->
		  	        </div>
		  	        <div class="col-xs-6">
		  				<h1 style="text-align:center">Data</h1>
		  				<table id="dbmsTableID" class="table table-bordered" style="table-layout: fixed; max-width:600px;">
		  					<div style="padding-top: 25px">
		  				    <!-- Table is empty because it is created by the updateTable, queryGen, or bnQueryGen method -->
		  					</div>
		  				</table>
		  	        </div>
		  			<!--Table Div End (Right Side) -->
		  	    </div>
		  	</div>
	    </div>
		<!-- End DBMS Tab -->
		
		<!-- Start File System Tab -->
	    <div id="fsID" class="tab-pane fade">
		  	<div class="container">
		  	    <div class="row">
		  			<!-- Form Div (Left Side) -->
		  	        <div class="col-xs-6">
		  				<h1 style="text-align:center">Data Entry</h1>
		  				<form id="fsFormID" class="form" method="post">
		  					<div class="form-group">
		  						<label for="subjectID2">Subject</label>
		  						<span class="glyphicon glyphicon-question-sign" data-toggle="tooltip" data-original-title="If the subject is not a URI it will be used as the fragment identifier of a Relative URI."></span> 
		  						<input type="text" class="form-control" placeholder="Subject" id="subjectID2">
		  						<p class="errorMessage" id="subjectErrorID2" ></p>
		  					</div>
		  					<div class="form-group">
		  						<label for="predicateID2">Predicate</label>
		  						<span class="glyphicon glyphicon-question-sign" data-toggle="tooltip" data-original-title="The predicate can either be a URI (ex. http://xmlns.com/foaf/0.1/name) or a curie (ex. foaf:name) because these are preloaded in Virtuoso."></span> 
		  						<input type="text" class="form-control" placeholder="Predicate" id="predicateID2">
		  						<p class="errorMessage" id="predicateErrorID2" ></p>
		  					</div>
		  					<div class="form-group">
		  						<label for="objectID2">Object</label> <span class="glyphicon glyphicon-question-sign" data-toggle="tooltip" data-original-title="Wether or not the Object is a literal value or a reference is determined by the range of the predicate. Quoting the Object will override this feature and make it a literal value."></span> 
		  						<input type="text" class="form-control" placeholder="Object" id="objectID2">
		  					</div>
		  					<div class="form-group">
		  						<label for="docNameID2">Document Name</label>
		  						<input type="text" class="form-control" value="https://kingsley.idehen.net/public_home/jordan/Public/record-test.ttl" id="docNameID2">
		  						<p class="errorMessage" id="docNameErrorID2" ></p>
		  					</div>
		  					<div class="form-group">
		  						<label for="endpointID2">SPARQL Endpoint (required for predicate lookup)</label> <span class="glyphicon glyphicon-question-sign" data-toggle="tooltip" data-original-title="Required for accepted relation object (values) lookup"></span> 
		  						<input type="text" class="form-control" id="endpointID2" size="35" value="https://linkeddata.uriburner.com/sparql"/>
		  					</div>

		  					<!-- Start Buttons -->
		  					<div class=button-wrapper>
		  					<span>
							<button id="clearBtnID" type="button" onclick="clearfs()" class="btn btn-primary">Clear</button>
							<button id="turtleBtnID2" type="button" onclick="turtleGen()" class="btn btn-success">Add</button>
							<button id="turtleBtnID2" type="button" onclick="turtleDel()" class="btn btn-danger">Delete</button>
		  					<button id="queryBtnID2" type="button" onclick="queryGen()" class="btn btn-warning">Query</button> 
		  					<button id="dataBtnID2" type="button" onclick="updateTable()" class="btn btn-info">All Data</button>
		  				    </span>
		  					</div>
		  					<!-- End Buttons -->
		  				</form>
		  				<!-- End of Form Div -->
					
		  			<!--Start Table Div (Right Side) -->
		  	        </div>
		  	        <div class="col-xs-6">
		  				<h1 style="text-align:center">Data</h1>
		  				<table id="fsTableID" class="table table-bordered" style="table-layout: fixed; max-width:600px;">
		  					<div style="padding-top: 25px">
		  				    <!-- Table is empty because it is created by the updateTable method -->
		  					</div>
		  				</table>
		  	        </div>
		  			<!--Table Div End (Right Side) -->
		  	    </div>
		  	</div>
	    </div>
		<!-- End File System Tab -->
	  </div>
	<!-- End of tabs container -->
	</div>
	<style>
		/* sets input field red if invalid */
		.error {
		  border:2px solid red;
		}
	
		/* sets error message color red */
		.errorMessage {
			color:red;
		}
	
		/* wraps text in table */
		td {
		  word-wrap: break-word;
		}
	</style>

	<!-- These Functions Modify the Onscreen Display -->
	<script>
		docNameValue() ; //Checks/Updates document name when page is loaded
		var solid_storage = null; 
	  
		//Tooltip activation function
		$(document).ready(function(){
		    $('[data-toggle="tooltip"]').tooltip({
		        placement : 'right'
		    }); 

		  const loginButton = document.getElementById('loginID');
		  const logoutButton = document.getElementById('logoutID');

		  solid.auth.trackSession(async (session) => {
	              const loggedHref = document.getElementById('logged-href')
	              const loggedIn = !!session
	              loginButton.classList.toggle('hidden', loggedIn)
	              logoutButton.classList.toggle('hidden', !loggedIn)
	              if (loggedIn) {
	                if (session.webId) {
	                  loggedHref.classList.remove('hidden')
	                  loggedHref.href = session.webId
	                  loggedHref.title = session.webId

	                  solid_storage = await fetchProfile(session.webId);
	                  sessionStorage.setItem('solid_storage', solid_storage);
	                }

	              } else {
	                loggedHref.classList.add('hidden')
	                loggedHref.href = ''
	                loggedHref.title = ''
	                solid_storage = null;
	                sessionStorage.removeItem('solid_storage');
	              }
	            })
		});
		
		/* Gets the solid storage from window > application > session storage 
		so it can be used as the document name for functions 
		function is called when page is loaded/reloaded */
		async function docNameValue() {
			solid_storage = await sessionStorage.getItem("solid_storage")
			var solid_storage_value = solid_storage + "mydata.ttl" ;
			console.log('solid storage: ' + solid_storage); 
			
			if (solid_storage == null) {
				document.getElementById("docNameID").value = "urn:records:test" ;
				document.getElementById("docNameID2").value = "https://kingsley.idehen.net/public_home/jordan/Public/record-test.ttl" ;		
			} else {
				document.getElementById("docNameID").value = solid_storage_value ;
				document.getElementById("docNameID2").value = solid_storage_value ;	
			}
		}

		// Clears dbms form
		function clearDBMS() {
			document.getElementById("dbmsFormID").reset();
			docNameValue() ;
		}
	
		// Clears file system form
		function clearfs() {
			document.getElementById("fsFormID").reset();
			docNameValue() ;
		}
	
		// This function checks which tab the user is in to determine focus of functions
		function tabCheck(id1, id2) {
			if (document.getElementById('dbmsTabID').getAttribute('class') == "active"){
				return document.getElementById(id1).value ;
			} else if (document.getElementById('fsTabID').getAttribute('class') == "active"){
				return document.getElementById(id2).value ;
			}
		}
	
		// This function checks which tab the user is in to determine table to display data (different because of .value)
		function tabCheckTable(id1, id2) {
			if (document.getElementById('dbmsTabID').getAttribute('class') == "active"){
				return document.getElementById(id1) ;
			} else if (document.getElementById('fsTabID').getAttribute('class') == "active"){
				return document.getElementById(id2) ;
			}
		}
	</script>

	<!-- These Functions are Used to Display Validation Errors -->
	<script>
		// Function is used to remove input field border color
		function setInputColor(id) {
			document.getElementById(id).className = document.getElementById(id).className + " error";  // this adds the error class
		}
	
		// Function is used to remove input field border color
		function removeInputColor(id) {
			document.getElementById(id).className = "form-control"; // removes error class
		}
	
		// Function is used to display error message
		function errorMessage(id, error) {
			document.getElementById(id).innerHTML = error ; 
		}
	</script>

	<!-- These Functions Handle the Form Validation -->
	<script>
		// Regular Expression for URIs
		const regexp = /^(?:(?:https?|ftp):\/\/)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})))(?::\d{2,5})?(?:\/\S*)?$/;

		// This function validates the uri used for PATCH
		document.getElementById("docNameID2").addEventListener("input", docNameValidation);
		function docNameValidation() {
			var str = document.getElementById("docNameID2").value ;
		 
			try {
				if (regexp.test(str)) { //removes error for valid uri
					errorMessage("docNameErrorID2", "") ; 
					removeInputColor('docNameID2') ;
				} else {
					setInputColor("docNameID2") ;
					errorMessage("docNameErrorID2", "Document name must be a full uri for patch method") ; 
					throw new Error("Document Name must be a full uri for patch method"); // Throws error because input is not a valid uri
				}
			} catch(e) {
				console.error('Invalid uri', e) ;
			}
		}
	
		// Function checks if input is a blank node
		function isBlankNode(str) {
			if (str.charAt(0) == "_" && str.charAt(1) == ":") {
				return str ;
			} else if (str.charAt(0) == "[" && str.charAt(str.length-1) == "]") {
				return str ;
			} else {
				return false ;
			}
		}
		
		function langTag(str) {
			const langexp = /@[a-zA-Z][a-zA-Z]/ ; // regexp for languge tag ex. @en
			if (langexp.test(str)) {
				return true ;
			} else {
				return false ;
			}
		}
	
		// Function formats literal inputs
		function formatLiteral(str) {
			if (langTag(str)) { // str has lang tag
				strArray = str.split('@') ; // split string at @ so the langtag is removed from string
				str = strArray[0].trim() ;
				langtag = '@' + strArray[1].trim() ; // need to add @ because it is removed by split 
				if (str.charAt(0) != '"' && str.charAt(0) != "'") {
					return '"' + str + '"' + langtag 
				} else {
					return str + langtag
				}
			} else { // str does not have lang tag
				if (isBlankNode(str)) {
					return str ;
				} else if (str.charAt(0) == "'" && str.charAt(str.length-1) == "'") {
					return str // If string begins and ends with single quote return it as is
				} else if (str.charAt(0) == '"' && str.charAt(str.length-1) == '"') {
					return str ;	
				} else if (str.indexOf(' ') >= 0){
					if (str.charAt(0) != '"' && str.charAt(0) != "'") {
						return '"' + str + '"' ;
					} else {
						return str ;
					} 
				} else {
					return '"' + str + '"' ;
				}
			}	
		}
	
		// This function formats the Subject input. Comments are inline
		function formatSubject() {
			if (document.getElementById('dbmsTabID').getAttribute('class') == "active"){
				var str = document.getElementById("subjectID").value ;
			} else if (document.getElementById('fsTabID').getAttribute('class') == "active"){
				var str = document.getElementById("subjectID2").value ;
			}
		
			if (regexp.test(str)) {
				return '<' + str + '>' ; // Case: input is a uri. Solution: quote it
			} else if (str.charAt(0) == "#") {
				return '<' + str + '>' ; // Case: input is an unquoted relative uri. Solution: quote it
			} else if (str.charAt(0) == '<' && str.charAt(1) == '#' && str.charAt(str.length-1) == '>') { 
				return str ; // Case: input is already a relative uri. Solution: return it as is
			} else if (str.includes(":")) {
				return str ; // Case: input is a curie. Solution: return it as is
			} else if (str.charAt(0) == "?") {
				return str ; // checks if input is a variable for deletion
			}
			else {
				if (str.charAt(0) == '<' && str.charAt(str.length-1) == '>') {
					var newStr = str.slice(1,-1); // Case: input is quoted uri. Solution: must be unquotted to be recognize as a uri by regexp
					return formatSubject(newStr) ;
				} else if (isBlankNode(str)) {
					return isBlankNode(str) ; // Case: input is a blank node. Solution: return it as is
				} else {
					return ':' + str ; // Case: input is not a uri or a blank node. Solution: make it a relative uri
				}
	        }
		}
	
		// If the subject is quoted or contains a space this function throws and error
		document.getElementById("subjectID").addEventListener("input", validateSubject);
		function validateSubject() {
			var str = tabCheck("subjectID", "subjectID2") ;
		
			try {
				if (isBlankNode(str)) { // removes error message for complete blank node
					errorMessage("subjectErrorID", "") ; 
					removeInputColor('subjectID') ;
					return formatSubject();
				} else if (str.includes('"') || str.includes("'")) {
					setInputColor("subjectID") ;
					errorMessage("subjectErrorID", "Subject cannot contain a literal value unless it is a blank node") ; 
					throw new Error("Subject cannot be a literal value"); // Throws error because input is a literal value
				} else if (str.indexOf(' ') >= 0){
					setInputColor('subjectID') ;
					errorMessage("subjectErrorID", "Subject cannot contain spaces unless it is a blank node") ; 
					throw new Error("Subject cannot contain spaces");
				} 
				else {
					errorMessage("subjectErrorID", "") ; 
					removeInputColor("subjectID") ;
					return formatSubject(); // Returns formatted subject because it is valid
				}
			} catch(e) {
				console.error('Invalid Subject', e) ;
			}
		
		}
	
		// This function formats the Predicate input. Comments are inline
		function formatPredicate() {
			var str = tabCheck("predicateID", "predicateID2") ;
		
			if (regexp.test(str)) {
				return '<' + str + '>' ; // Case: input is a uri. Solution: quote it
			} else if (str.charAt(0) == "#") {
				return '<' + str + '>' ; // Case: input is an unquoted relative uri. Solution: quote it
			} else if (str.charAt(0) == '<' && str.charAt(1) == '#' && str.charAt(str.length-1) == '>') { 
				return str ; // Case: input is already a relative uri. Solution: return it as is
			} else if (str.includes(":")) {
				return str; // Case: input is a curie. Solution: return it as is
			} else if (str.charAt(0) == "?") {
				return str ; // checks if input is a variable for deletion
			}
			else {
				if (str.charAt(0) == '<' && str.charAt(str.length-1) == '>') {
					var newStr = str.slice(1,-1); // Case: input is quoted uri. Solution: must be unquotted to be recognize as a uri by regexp
					return formatPredicate(newStr) ;
				} else {
					return ':' + str ; // Case: input is not a uri or a blank node. Solution: make it a relative uri
				}
	        }
		}
	
		// If the predicate is quoted, contains, or is a blank node a space this function throws and error
		document.getElementById("predicateID").addEventListener("input", validatePredicate);
		function validatePredicate() {
			var str = tabCheck("predicateID", "predicateID2") ;
		
			try {
				if (str.includes('"') || str.includes("'")) {
					setInputColor('predicateID') ;
					errorMessage("predicateErrorID", "Predicate cannot be a literal value") ;
					throw new Error("Predicate cannot be a literal value"); // Throws error because input is a literal value
				} else if (str.indexOf(' ') >= 0){
					setInputColor('predicateID') ;
					errorMessage("predicateErrorID", "Predicate cannot contain spaces") ; 
					throw new Error("Predicate cannot contain spaces"); // Throws error because input subject can't contain spaces
				} else {
					removeInputColor('predicateID') ;
					errorMessage("predicateErrorID", "") ; 
					return formatPredicate(); // Returns formatted subject because it is valid
				}
			} catch(e) {
				console.error('Invalid Predicate', e) ;
			}	
		}
	
		// This function formats the Object input. Comments are inline
		async function validateObject() {
			var range = await predicateRange() ; // function waits until range is a value rather than a promise
			var str = tabCheck("objectID", "objectID2") ;
		
			if (str.includes('"') || str.includes("'")) {
				range = true ;
			}
		
			if (!range) {
				if (regexp.test(str)) {
					return '<' + str + '>' ; // Case: input is a uri. Solution: quote it
				} else if (str.charAt(0) == "#") {
					return '<' + str + '>' ; // Case: input is an unquoted relative uri. Solution: quote it
				} else if (str.charAt(0) == '<' && str.charAt(1) == '#' && str.charAt(str.length-1) == '>') { 
					return str ; // Case: input is already a relative uri. Solution: return it as is
				} else if (str.includes(":")) {
					return str; // Case: input is a curie. Solution: return it as is
				} 
				else {
					if (str.charAt(0) == '<' && str.charAt(str.length-1) == '>') {
						var newStr = str.slice(1,-1); // Case: input is quoted uri. Solution: must be unquotted to be recognize as a uri by regexp
						return validateObject(newStr) ;
					} else {
						return ':' + str ; // Case: input is not a uri or a blank node. Solution: make it a relative uri
					}
		        }
			} 
			else {
				return formatLiteral(str);			
	        }
		}
	
		// This function formats the Object input. Comments are inline
		function nonvalidatedObject() {
			var str = tabCheck("objectID", "objectID2") ;
		
			if (regexp.test(str)) {
				return '<' + str + '>' ; // Case: input is a uri. Solution: quote it
			} else if (str.charAt(0) == "#") {
				return '<' + str + '>' ; // Case: input is an unquoted relative uri. Solution: quote it
			} else if (str.charAt(0) == '<' && str.charAt(1) == '#' && str.charAt(str.length-1) == '>') { 
				return str ; // Case: input is already a relative uri. Solution: return it as is
			} else if (str.includes(":")) {
				return str; // Case: input is a curie. Solution: return it as is
			} else if (str.charAt(0) == "?") {
				return str ; // checks if input is a variable for deletion
			} else if (str.charAt(0) == '<' && str.charAt(str.length-1) == '>') {
					var newStr = str.slice(1,-1); // Case: input is quoted uri. Solution: must be unquotted to be recognize as a uri by regexp
					return nonvalidatedObject(newStr) ;
			} else if (str.includes('"') || str.includes("'") || str.indexOf(' ') >= 0) {
				return formatLiteral(str) ; // Case: input is a quoted literal value
			}
			else {
				return ':' + str ; // Case: input is not a uri or a blank node. Solution: make it a relative uri
				} 			
		}
	
		// This function allows hyperlinks to be used in the table
		function tableFormat(str) {
			if (regexp.test(str) || str.charAt(0) == "#") {
				str = '<a href="' + str + '">' + str + '</a>'
				return str
			}
			else {
				return str
			}

		}
	
		// This function is used to referesh the table when view data is clicked
		function refreshTable() {
			var table = tabCheckTable("dbmsTableID", "fsTableID") ;

			for (var i = document.getElementById(table.id).rows.length; i > 0; i--) {
				document.getElementById(table.id).deleteRow(i -1);
			}
		}
	
		// This function is used to create header row of table
		function createHeader() {
			var table = tabCheckTable("dbmsTableID", "fsTableID") ;
			
			var header = table.createTHead(); // creates empty tHead
			var row = header.insertRow(0); // inserts row into tHead
		
			var cell0 = row.insertCell(0); // inserts new cell at position 0 in the row
			var cell1 = row.insertCell(1); // inserts new cell at position 1 in the row
			var cell2 = row.insertCell(2); // inserts new cell at position 2 in the row
		
			cell0.innerHTML = "<b>Subject</b>"; // adds bold text
			cell1.innerHTML = "<b>Predicate</b>";
			cell2.innerHTML = "<b>Object</b>";
		}
	
	</script>
	
	<!-- These Functions Handle the Functionality of the Page -->
	<script>
		updateTable(); //Table is always shown when page is loaded
	
		//SPARQL INSERT SCRIPT
	    async function recordGen() {
		    var subject = validateSubject() ;
			var predicate = validatePredicate() ;
			var object = await validateObject() ; // insert function awaits object value before proceeding
			var graph = document.getElementById("docNameID").value ;
	
		    //SPARQL INSERT Query Generator
		    var insert_cmd = 
			"PREFIX schema: <http://schema.org/>\n" 
			+ "PREFIX : <" + graph + "#>\n" 
			+ "PREFIX foaf: <http://xmlns.com/foaf/0.1/>\n"
			+ "INSERT INTO GRAPH <" +graph+ "> \n{\n" 
			+ subject + ' ' + predicate + ' ' + object + " . \n"
			+ "}";
			
			var endpoint = document.getElementById("endpointID").value ;
	        let url = endpoint ;

	        console.log("endpoint for Target SPARUL Service: " + endpoint);
	        console.log(insert_cmd);
	        const options = {
	                            method: 'POST',
	                            headers: {
	                                       'Content-type': 'application/sparql-update; charset=UTF-8',
										 },
	                            credentials: 'include',
	                            mode: 'cors',
	                            crossDomain: true,
	                            body: insert_cmd,
	        };
		
			try {
		        var resp = await fetch(url, options);
				if (resp.status >= 200 && resp.status <= 300) {
					console.log(resp.status + " - " + resp.statusText) ;
					updateTable() ;
				} else {
					console.log("Error " + resp.status +" - " + resp.statusText) ;
				}
			} catch(e) {
				console.error('Insert Failed:', e) ;
			}			     
		}
	
     	//SPARQL DELETE SCRIPT
	   	async function recordDel() {
     	    var subject = validateSubject() ;
     	    var predicate = validatePredicate() ;
     		var object = nonvalidatedObject() ;
     		var graph = document.getElementById("docNameID").value ;

     	    //SPARQL DELETE Query Generator
    		var delete_cmd = 
   			"PREFIX : <" + graph + "#>\n" 
    		+ "DELETE { GRAPH <" + graph + "> {\n"
    		+ subject + ' ' + predicate + ' ' + object + "."
    		+ "\n }"
   			+ "\n }"
    		+ "WHERE { GRAPH <" + graph + "> { \n"
    		+ subject + ' ' + predicate + ' ' + object + "."
    		+ "} \n };"	

            var endpoint = document.getElementById("endpointID").value ;
            let url = endpoint ;

            console.log("endpoint for Target SPARUL Service: " + endpoint);
            console.log(delete_cmd);
            const options = {
                                method: 'POST',
                                headers: {
                                           'Content-type': 'application/sparql-update; charset=UTF-8',
     									},
                                credentials: 'include',
                                mode: 'cors',
                                crossDomain: true,
                                body: delete_cmd,
            };
			try {
				var resp = await fetch(url, options);
				if (resp.status >= 200 && resp.status <= 300) {
					console.log(resp.status + " - " + resp.statusText);
					updateTable() ;
				}
				else {
					console.log("Error " + resp.status +" - " + resp.statusText) ;
				}	
			} catch(e) {
				console.error('Delete Failed:', e) ;
			}
		
	   	}
		
		/* Generates blank node queries and displays table reflecting them.
		This function is required because blank node queries can 
		require n number of columns. */
		async function bnQueryGen() {
		    var subject = validateSubject() ;
			var predicate = validatePredicate() ;
			var object = nonvalidatedObject() ;
			var graph = tabCheck("docNameID", "docNameID2") ;
			
			
			if (document.getElementById('dbmsTabID').getAttribute('class') == "active") { 
			    var query = 
				"PREFIX : <" + graph + "#>\n" 
				+ "SELECT DISTINCT * \n"
				+ "FROM <" + graph + "> \n" 
				+ "WHERE {" + " " + subject + " " + predicate + " " + object + " " + "}"
			} else if (document.getElementById('fsTabID').getAttribute('class') == "active") {
			    var query = 
				"DEFINE get:soft" + " " + '"soft"' + "\n"
				+ "PREFIX : <" + graph + "#>\n" 
				+ "SELECT DISTINCT * \n"
				+ "FROM <" + graph + "> \n" 
				+ "WHERE {" + " " + subject + " " + predicate + " " + object + " " + "}"
			}
			
			var endpoint = tabCheck("endpointID", "endpointID2") + "?default-graph-uri=&query=" ;
	        let url = endpoint + encodeURIComponent(query) + "&should-sponge=&format=application%2Fsparql-results%2Bjson" ;
			
	        console.log("SPARQL Query: " + query);
			console.log("Query URL: " + url)
		
	        const options = {
	                            method: 'GET',
	                            headers: {
	                                       'Content-type': 'application/sparql-results+json; charset=UTF-8',
										 },
	                            credentials: 'include',
	                            mode: 'cors',
	                            crossDomain: true,
	                        };
			try {
		        var resp = await fetch(url, options)
			
				.then((res) => res.json())
		        .then( data =>{
				
				    refreshTable();
					
					/*
                    Dynamic Table for processing JSON Structured Data (via "application/sparql-results+json" document content type)
                    that enables INSERT to be handled via a 3-tuple subject, predicate, object graph (relation) while query results 
                    are handled via an N-Tuple structured table (relation).
                    */
		            if (data.results.bindings.length > 0){
						var table = tabCheckTable("dbmsTableID", "fsTableID") ; // creates table for header
						var header = table.createTHead(); // creates empty tHead
						var headRow = header.insertRow(0); // inserts row into tHead
						var bindings = data.results.bindings;
						for (var col = 0; col < data.head.vars.length; col++) { // for each column
							var headCell = headRow.insertCell(col); // inserts new cell at position i in thead
							headCell.innerHTML = "<b>" + data.head.vars[col] + "</b>"; // adds bold text to thead cell
							for (i in bindings) {
								var binding = bindings[i];
								var bodyRow = table.insertRow(-1); // create new row
								for (n in binding) {
									var bodyCell = bodyRow.insertCell(n); // create new cell in row
									bodyCell.innerHTML = tableFormat(binding[n].value); // set value of cell
								}
							}
						}
		            }	
		            else{
						throw new Error("No Data Returned");
						console.log("No data returned by query");
		            }
				})
			} catch(e) {
				console.error('Query Failed:', e) ;
			}		   
			
		}
	
		// This function updates table to show results of a query
		async function queryGen() {
		    var subject = validateSubject() ;
			var predicate = validatePredicate() ;
			var object = nonvalidatedObject() ;
			var graph = tabCheck("docNameID", "docNameID2") ;	
			
			if (isBlankNode(subject) || isBlankNode(object)) {
				bnQueryGen(); // if query includes blank node call bnQueryGen function
				return false ; // returns false so the queryGen function stops executing
			}
			
			if (document.getElementById('dbmsTabID').getAttribute('class') == "active") { 
			    var query = 
				"PREFIX : <" + graph + "#>\n" 
				+ "SELECT DISTINCT" + " " + subject + " AS ?subject" + " " + predicate + " AS ?predicate" + " " + object + " AS ?object \n"
				+ "FROM <" + graph + "> \n" 
				+ "WHERE {" + " " + subject + " " + predicate + " " + object + " " + "}"
			} else if (document.getElementById('fsTabID').getAttribute('class') == "active") {
                var query =
				"DEFINE get:soft" + " " + '"soft"' + "\n"
				+ "PREFIX : <" + graph + "#>\n" 
				+ "SELECT DISTINCT" + " " + subject + " AS ?subject" + " " + predicate + " AS ?predicate" + " " + object + " AS ?object \n"
				+ "FROM <" + graph + "> \n" 
				+ "WHERE {" + " " + subject + " " + predicate + " " + object + " " + "}"
			}
			
			var endpoint = tabCheck("endpointID", "endpointID2") + "?default-graph-uri=&query=" ;
	        let url = endpoint + encodeURIComponent(query) + "&should-sponge=&format=application%2Fsparql-results%2Bjson" ;

	        console.log("SPARQL Query: " + query);
			console.log("Query URL: " + url)
		
	        const options = {
	                            method: 'GET',
	                            headers: {
	                                       'Content-type': 'application/sparql-results+json; charset=UTF-8',
										 },
	                            credentials: 'include',
	                            mode: 'cors',
	                            crossDomain: true,
	                        };
			try {
		        var resp = await fetch(url, options)
			
				.then((res) => res.json())
		        .then( data =>{
				
				    refreshTable();
					createHeader();

		            if (data.results.bindings.length > 0){
						var table = tabCheckTable("dbmsTableID", "fsTableID") ;
						var object = nonvalidatedObject() ;
						for (var i = 0; i < data.results.bindings.length; i++) {	
							subject = data.results.bindings[i].subject.value ;
							predicate = data.results.bindings[i].predicate.value ;
							object = data.results.bindings[i].object.value ;	

							var row = table.insertRow(-1);
						    var cell1 = row.insertCell(0);
						    var cell2 = row.insertCell(1);
						    var cell3 = row.insertCell(2);

						    cell1.innerHTML = tableFormat(subject);
						    cell2.innerHTML = tableFormat(predicate);
						    cell3.innerHTML = tableFormat(object);	
						}
		            }
		            else{
						throw new Error("No Data Returned");
						console.log("No data returned by query");
		            }
				})
			} catch(e) {
				console.error('Query Failed:', e) ;
			}		   
		}
	
		// This function fetches the query results and returns them in json
	    async function updateTable() {
			var graph = tabCheck("docNameID", "docNameID2") ;
			
			if (document.getElementById('dbmsTabID').getAttribute('class') == "active") {
			    var data_query = 
				"SELECT DISTINCT * FROM <" + graph + "> WHERE {?subject ?predicate ?object}"
			} else if (document.getElementById('fsTabID').getAttribute('class') == "active") {
				// Use of Sponger Pragma to force document reload during query evaluation
				var data_query = 
				"DEFINE get:soft" + " " + '"soft"' + "\n" + "SELECT DISTINCT * FROM <" + graph + "> WHERE {?subject ?predicate ?object}"
			}

            var endpoint = tabCheck("endpointID", "endpointID2") + "?default-graph-uri=&query=" ;
	        let url = endpoint + encodeURIComponent(data_query) + "&should-sponge=&format=application%2Fsparql-results%2Bjson" ;

	        console.log("Retrieving Table Data From: " + url);
		
	        const options = {
	                            method: 'GET',
	                            headers: {
	                                       'Content-type': 'application/sparql-results+json; charset=UTF-8',
										 },
	                            credentials: 'include',
	                            mode: 'cors',
	                            crossDomain: true,
	                        };
			
			try {
		        var resp = await fetch(url, options)
	
				.then((res) => res.json())
		        .then( data =>{
					
				    refreshTable();
					createHeader();
					var table = tabCheckTable("dbmsTableID", "fsTableID") ;
					
		            if (data.results.bindings.length > 0){
						for (var i = 0; i < data.results.bindings.length; i++) {	
							subject = data.results.bindings[i].subject.value ;
							predicate = data.results.bindings[i].predicate.value ;
							object = data.results.bindings[i].object.value ;	
				
							var row = table.insertRow(-1);
						    var cell1 = row.insertCell(0);
						    var cell2 = row.insertCell(1);
						    var cell3 = row.insertCell(2);

						    cell1.innerHTML = tableFormat(subject);
						    cell2.innerHTML = tableFormat(predicate);
						    cell3.innerHTML = tableFormat(object);	
						}
		            }
		            else{
						console.log("No data found by lookup");
		            }
				})	
			} catch(e) {
				console.error('Table Refresh Failed:', e) ;
			}		  
	    }
	
		// This function gets the range of the predicate to determine if object is a literal or a reference
		async function predicateRange() {
			var predicate = validatePredicate() ; 
			var graph = tabCheck("docNameID", "docNameID2") ;
		
		    var range_query =
			"PREFIX : <" + graph + "#>\n" 
			+ "ASK \n"
			+ "WHERE \n"
			+ "{ \n"
			+ predicate + ' ' + "rdfs:range ?range .\n"
			+ "filter (?range in (rdfs:Literal, xsd:string, xsd:decimal, xsd:integer, xsd:boolean, xsd:date, xsd:time))\n"
			+"}" 		
			
            var endpoint = tabCheck("endpointID", "endpointID2") + "?default-graph-uri=&query=" ;
			// This sets the url for retrieving the json
	        let url = endpoint + encodeURIComponent(range_query) + "&should-sponge=&format=application%2Fsparql-results%2Bjson" ; 

	        console.log("Recieving Predicate Range From: " + url);
		
	        const options = {
	                            method: 'GET',
	                            headers: {
	                                       'Content-type': 'application/sparql-results+json; charset=UTF-8',
										 },
	                            credentials: 'include',
	                            mode: 'cors',
	                            crossDomain: true,
	        };
		
			try {
				const resp = await fetch(url, options); // resp awaits completion of fetch 
			
				if (resp.status >= 200 && resp.status <= 300) {
					console.log(resp.status + " - " + resp.statusText);
				} else {
					console.log("Error " + resp.status +" - " + resp.statusText) ;
				}
				const json = await resp.json(); // constant awaits resp before being assigned (so it isn't assigned as a promise)
				return (json.boolean) ; // returns true or false returned by query after awaiting results
			} catch(e) {
				console.error('Predicate Range Lookup Failed:', e) ;
			}		
		
		}
	
		async function turtleGen() {
		    var subject = validateSubject() ;
			var predicate = validatePredicate() ;
			var object = await validateObject() ; // insert function awaits object value before proceeding
			var docName = document.getElementById("docNameID2").value ;

			var turtle_cmd = 
			"" + "INSERT DATA {@prefix : <" + docName + "#> ." + ' ' + subject + ' ' + predicate + ' ' + object + ' ' + ".}" + ""
			
			let url = docName ;

	        console.log("Fetch Command:" + turtle_cmd);
		
	        const options = {
	                            method: 'PATCH',
	                            headers: {
	                                       'Content-type': 'application/sparql-update; charset=UTF-8',
										 },
	                            credentials: 'include',
	                            mode: 'cors',
	                            crossDomain: true,
	                            body: turtle_cmd,
	        };
		
			try {
		        var resp = await fetch(url, options);
				if (resp.status >= 200 && resp.status <= 300) {
					console.log(resp.status + " - " + resp.statusText);
					updateTable() ;
				}
				else {
					console.log("Error " + resp.status +" - " + resp.statusText) ;
				}
			} catch (e) {
				console.error('Request Failed:', e) ;
			}			
		}
		
		async function turtleDel() {
		    var subject = validateSubject() ;
			var predicate = validatePredicate() ;
			var object = nonvalidatedObject() ; // insert function awaits object value before proceeding
			var docName = document.getElementById("docNameID2").value ;

			var del_cmd = 
			"" + "PREFIX : <" + docName + "#> DELETE DATA" + ' ' + "{" + subject + ' ' + predicate + ' ' + object + ' ' + ".}" + ""
		
			let url = docName ;

	        console.log("Fetch Command:" + del_cmd);
		
	        const options = {
	                            method: 'PATCH',
	                            headers: {
	                                       'Content-type': 'application/sparql-update; charset=UTF-8',
										 },
	                            credentials: 'include',
	                            mode: 'cors',
	                            crossDomain: true,
	                            body: del_cmd,
	        };
		
			try {
		        var resp = await fetch(url, options);
				if (resp.status >= 200 && resp.status <= 300) {
					console.log(resp.status + " - " + resp.statusText);
					updateTable() ;
				}
				else {
					console.log("Error " + resp.status +" - " + resp.statusText) ;
				}
			} catch (e) {
				console.error('Request Failed:', e) ;
			}			
		}
	</script>
	
	<!-- These functions are used for Authentication -->
	<script>
        async function fetchProfile(webId) {
           try {
             var rc = await loadProfile(webId);

             var uriObj = new URL(webId)
             uriObj.hash = uriObj.search = uriObj.query = '';

             var base = uriObj.toString()
             const kb = $rdf.graph()

             $rdf.parse(rc.profile, kb, base, rc.content_type);

             const LDP = $rdf.Namespace("http://www.w3.org/ns/ldp#");
             const PIM = $rdf.Namespace("http://www.w3.org/ns/pim/space#");

             const s_webId = $rdf.sym(webId)

             uriObj.pathname = '/';
             var ret = uriObj.toString();

             var store = kb.any(s_webId, PIM('storage'));
             var inbox = kb.any(s_webId, LDP('inbox'));
             if (inbox)
               ret = inbox.value;
             else if (store)
               ret = store.value;

             return ret;
           } catch(e) {
       	    console.error('Error:', e)
       	    return null;
           }
        }

        async function loadProfile(url) {
           const options = {
                             method: 'GET',
                             headers: {'Accept': 'text/turtle, application/ld+json'},
                             credentials: 'include',
                             mode: 'cors',
                             crossDomain: true,
                         };
           try {
               var resp = await solid.auth.fetch(url, options);
               if (resp.ok) {
 		  var body = await resp.text();
 		  var contentType = resp.headers.get('content-type');
 		  return {profile: body, contentType};
               } 
 	      else {
 	        console.log("Error " + resp.status +" - " + resp.statusText)
               }
           } 
 	  catch(e) {
       	      console.error('Request failed:', e)
           }
        }

        async function authLogin() {
            const popupUri = './common/popup.html'

            const session = await solid.auth.popupLogin({ popupUri })
            if (session) {
                // Make authenticated request to the server to establish a session cookie
               const {status} = await solid.auth.fetch(location, { method: 'HEAD' })

               if (status === 401) {
                   alert(`Invalid login.\n\nDid you set ${session.idp} as your OIDC provider in your profile ${session.webId}?`)
                   await solid.auth.logout()
               }
               // Now that we have a cookie, reload to display the authenticated page
               location.reload()
            }
        }
       
        async function authLogout () {
            await solid.auth.logout()
            location.reload()
        }
	</script>
  </body>
</html>
